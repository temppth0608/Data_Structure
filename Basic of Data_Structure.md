```
최종 작성자 : 박태현
최초 작성일 : 2016년 4월 10일
마지막 수정 : 2016년 4월 10일, 박태현
```

# 자료구조에 대한 기본적인 이해

## 자료구조란
**'데이터의 저장'을 담당하는 것**<br>
선형구조<br>
1. 리스트
2. 스택
3. 큐<br>
비선형구조<br>
1. 트리
2. 그래프<br>

** 선형 자료구조 - 데이터를 선의 형태로 나란히 혹은 일렬로 저장하는 방식(Linear) **<br>
** 비선형 자료구조 - 데이터를 나란히 저장하지 않는 구조**

## 알고리즘의 성능분석 방법
**시간 복잡도 - 속도에 해당하는 알고리즘의 수행시간 분석결과**<br>
**공간 복잡고 - 메모리 사용량에 대한 분석결과**<br>
*일반적으로 알고리즘을 평가할 때는 메모리의 사용량보다 실행속도에 초점을 둠(물론 특정 알고리즘에 대해서 상대적인 우월성을 입증해야 하는 경우에는 메모리의 사용량도 함께 고려가 됨)*<br>

```
알고리즘의 수행속도 평가방법
1. 연산의 횟수를 샘
2. 이후 처리해야 할 데이터의 수 n에 대한 연산횟수의 함수 T(n)을 구성함
```

### 순차 탐색(Linear Search) 알고리즘과 시간 복잡도 분석의 핵심요소
```
int LSearch(int ar[], int len, int target) {
	int i;
	for(i = 0; i < len; i++) {
		if(ar[i] == target)
			return i;
	}
	return -1;
}
```
Linear Search의 경우 운이 좋아서 찾고자하는 값이 배열의 맨 앞에 저장되어있으면 연산 횟수는 1이 되고 맨 뒤에 저장되어있으면 n(배열 크기)이 된다.<br>
**최선의 경우 - best case**<br>
**최악의 경우 - worst case**<br>
**평균적 경우 - average case**<br>
*일반적인 알고리즘의 평가에는 논란의 소지가 거의 없는 'worst case'를 고려해서 알고리즘을 평가해야함*<br><br>
Linear Search의 시간 복잡도 - n(결과가 없는경우) * 1/2(탐색 실패 or 탐색 성공) + n/2(average case) * 1/2(탐색 실패 or 탐색 성공) = 3/4n

### 이진 탐색(Binary Search) 알고리즘의 소개

```
int BSearch(int ar[]. int len, int target) {
	int first = 0;
	int last = len - 1;
	int mid;

	while(first <= last) {
		mid = (first + last) / 2
		if (ar[mid] == target)
			return mid;
		else { 
			if (ar[mid] < target)
				first = mid + 1;
			else 
				last = mid - 1;
		}
	}
	return -1;
}
```
진행 순서(Worst case)<br>
1. 처음에 데이터 수가 n개일 때의 탐색과정에서 1회의 비교연산 진행<br>
2. 데이터 수를 반으로 줄여 그 수가 2/n개일 때의 탐색과정에서 1회 비교연산 진행<br>
3. 데이터 수를 반으로 줄여 그 수가 4/n개일 때의 탐색과정에서 1회 비교연산 진행<br>
4. ...<br>
5. 데이터 수를 반으로 줄여 그 수가 1개일 때의 탐색과정에서 1회 비교연산 진행<br>

**Binary Search의 시간복잡도 - log(2)n**

## 빅오 표기법
ex)<br>
1. T(n) = n(2제곱) + 2n + 9 -> O(n(2제곱))<br>
2. T(n) = 5n(3제곱) + 9n(2제곱) -> O(n(3제곱))<br>

### 대표적인 빅-오
1. O(I) - 상수형 빅오. 이는 데이터 수에 상관없이 연산횟수가 고정인 유형의 알고리즘을 뜻한다. 예를들어 연산의 횟수가 데이터 수에 상관없이 3회 진행되는 알고리즘일지라도 O(3)이라고 하지않고 O(I)라고 한다.
2. O(log n) - 로그형 빅오. 이는 '데이터 수의 증가율'에 비해서 '연산횟수의 증가율'이 훨씬 낮은 알고리즘을 의미. 따라서 매우 바람직한 유형이다. 참고로 로그의 밑이 얼마냐에 따라서 차이가 나긴 하지만, 그 차이는 알고리즘의 성능관점에서 매우 미미하기 때문에 대부분의 경우에 있어 무시가된다.
3. O(n) - 선형 빅오. 이능 데이터의 수와 연산횟수가 비례하는 알고리즘을 의미
4. O(n log n) - 선형 로그형 빅오. 이는 데이터의 수가 두배로 늘 때, 연산횟수는 두배를 조금 넘게 증가하는 알고리즘을 의마한다. n과 log n을 곱한 형태라서 난해해 보이지만, 알고리즘 중에는 이에 해당하는 알고리즘이 적지 않다.
5. O(n(2제곱)) - 이는 데이터 수의 제곱에 해당하는 연산횟수를 요구하는 알고리즘을 의미한다. 따라서 데이터의 양이 많은 경우에는 적용하기가 부적절한데, 이는 이중으로 중첩된 방복문 내에서 알고리즘에 관련된 연산이 진행되는 경우에 발생한다. 달리 말하면 중첩된 반복문의 사용은 알고리즘 디자인에서 그리 바람직하지 못하다가고 할 수 있다.
6. O(2(n제곱)) - 지수형 빅오. 이는 사용하기에 매우 무리가 있는, 사용한다는 것 자체가 비현실적인 알고리즘이다. 지수적 증가라는 매우 무서운 연산횟수의 증가를 보이기 때문이다.
