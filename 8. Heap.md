```
최종 작성자 : 박태현
최초 작성일 : 2016년 4월 11일
마지막 수정 : 2016년 4월 11일, 박태현
```
# 우선순위 큐와 힙
##우선순위 큐의 이해
일반적인 큐 - 먼저 들어간 데이터가 먼저 나온다.(ex. 줄서기)

우선순위 큐 - 들어간 순서에 상관없이 우선순위가 높은 데이터가 먼저 나온다.(ex. 응급상황)

우선순위 큐를 단순 배열 또는 연결 리스트를 기반하여 구현했을때 단점

1. 데이터를 삽입 및 삭제하는 과정에서 데이터를 한 칸씩 뒤로 밀거나 한 칸씩 앞으로 당기는 연산을 수반해야함
2. 삽입의 위치를 찾기 위해서 배열에 저장된 모든 데이터와 우선순위의 비교를 진행해야 할 수도 있음
3. 삽입의 위치를 찾기 위해서 첫번째 노드에서부터 시작해서 마지막 노드에 저장된 데이터와 우선순위의 비교를 진행해야 할 수 도있음.

## 힙
**우선순위 큐를 단순 벼열이나 연결 리스트로 구현하지 않고 힙이라는 자료구조를 사용하여 구현함**

힙 - '이진트리'이되 '완전 이진트리'이다. 그리고 모든 노드에 저장된 값은 자식 노드에 저장된 값보다 크거나 같아야 한다. 즉 루트 노드에 저장된 값이 가장 커야 한다.

* 최대 힙 - 루트 노드로 올라갈수록 저장된 값이 커지는 완전 이진 트리
* 최소 힙 - 로트 노드로 올라갈수록 저장된 값이 작아지는 완전 이진 트리

힙의 삽입 과정 - 새로운 데이터의 우선순위가 제일 낮다는 가정하에 '마지막 위치'에 저장시킨후 부모 노드와 우선순위를 비교해서 위치가 바뀌어야 한다면 바꿔줌(바뀐 후에도 계속해서 부모 노드와 비교)

힙의 삭제 과정(루트 노드 삭제시) - 마지막 노드를 루트 노드의 자리로 옮긴 다음에, 자식 노드와의 비교를 통해서 제자리를 찾아가게 함


```
* 배열 기반 데이터 저장의 시간 복잡도 -> O(n)
* 배열 기반 데이터 삭제의 시간 복잡도 -> O(I)

* 연결 리스트 기반 데이터 저장의 시간 복잡도 -> O(n)
* 연결 리스트 기반 데이터 삭제의 시간 복잡도 -> O(I)

* 힙 기반 데이터 저장의 시간 복잡도 -> O(log(2)n)
* 힙 기반 데이터 삭제의 시간 복잡도 -> O(log(2)n)
```

**힙을 구현할때는 연결 리스트보다 배열로 구현하는 것이 일반적 사실 - 연결 리스트 기반으로 구현할 경우, 새로운 노드를 힙의 '마지막 위치'에 추가하는 것이 쉽지 않다.**

```
배열 기반 힙에서 인덱스 얻는 방법
* 왼쪽 자식 노드의 인덱스 값 - 부모 노드의 인덱스 값 x 2
* 오른쪽 자식 노드의 인덱스 값 - 부모 노드의 인덱스 값 x 2 + 1
* 부모 노드의 인덱스 값 - 자식 노드의 인덱스 값 / 2
```
